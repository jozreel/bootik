var net = require('http');
var config = require('simple').config;
var buff = require('buffer').Buffer;
var url = require('url');
 var sockets = require('sockets');
var websocket = function(req,socket,head)
{
	this.req = req;
	this.socket = socket;
	this.head = head;
	var obj = this;
	this.socket.on('data', function(data){obj.onData(data);});
	this.socket.on('close', function(){obj.onclose()});
	/*/this.req.on('upgrade', function(res, socket, upgradeHead) {
    console.log('got upgraded!');
    socket.end();
    process.exit(0);
	this.bigLenght = 0;
	
  });*/
	this.continiousData = [];
	this.appid = "";
	this.user='';
	this.params=[];
}

websocket.prototype.upgrade = function(receive, send)
{
	
	   
	      var trmd = this.req.headers['sec-websocket-key'].trim();
		  var crypto =require('crypto');
			var crypt = crypto.createHash('sha1').update(trmd+'258EAFA5-E914-47DA-95CA-C5AB0DC85B11').digest('base64');
			
			var respns = 'HTTP/1.1 101 Switching Protocols\r\n'+
                          'Upgrade: websocket\r\n'+
                           'Connection: Upgrade\r\n'+
                            'Sec-WebSocket-Accept: '+crypt+ '\r\n'+
							'\r\n';
	
	   this.socket.write(respns,function(err)
	   
	   {
		   if(err)
		     console.log(err);});
	   
	   //this.socket.pipe(this.socket);
	   try{
		var urlparts = url.parse(this.req.url,true);
		
		var pathnm = urlparts.pathname.slice(1);
		
	
		var arrurl = pathnm.split('/');
	    var  quer = urlparts.query;
		
		 
		
		 var ctrl = arrurl[0];
		 arrurl.shift();
		
		 this.receiver = arrurl[0]; 
		 arrurl.shift();
		 
		 arrurl = arrurl.map(function(x){return websocket.replaceSpecial(x);});
		 if(arrurl.length > 0)
		    this.params = arrurl;
		// this.reciever = arrurl[1];
	     var reslv = require.resolve('../application/controller/'+ctrl);
		 var ctr = require('../application/controller/'+ctrl);
		 this.controler = ctr;
		 this.controler.req.requestdata = quer;
		 ctr.socket = this.socket;
		 ctr.setSocket(this.socket);
		   	
		
		//var ext = path.extname(reslv);
		//var fn = path.basename(reslv.slice(0,-ext.length));
		//ctr = require('../application/controller/'+fn);
	   }
	   catch(err)
	   {
		   console.log(err);
	   }
	   
}

websocket.replaceSpecial = function(txt)
{
	
	//console.log(txt);
	return txt.replace(/&/g, '&amp;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');

}

websocket.prototype.onData=function(data)
{
	
	this.readMessage(data);
}

websocket.prototype.readMessage = function(data)
{
	var next = 2;
	var key =[];
	
	
	
	var FIN = (data[0] & 0x80);
    var RSV1 = (data[0] & 0x40);
     var RSV2 = (data[0] & 0x20);
     var RSV3 = (data[0] & 0x10);
	 var mask = (data[1] & 0x80);
	 var Opcode = data[0]& 0x0F;;
	//console.log((data[1] - 128));
	
	if((data[1] - 128) <= 125 )
	  length = data[1] - 128;
	else if((data[1] - 128) === 126)
	{
		next+= 2;
		length = (data[2] & 0xFF) << 8 | (data[3] & 0xFF);
	}
	else if((data[1] - 128) ===127)
	{  
		next+=8;
		 var arr1 = ((data[2] & 0xFF) << 24  | (data[3] & 0xFF) <<16 | (data[4] & 0xFF) << 8 | data[5] & 0xFF);
		
		
	      var arr2=   ((data[6] & 0xFF) <<24 | (data[7] & 0xFF) <<16 | (data[8] & 0xFF) <<8 | data[9] & 0xFF);
		  
		  length = arr1+ arr2;
	}

	 var decoded = new buff(length);
	

	if(mask)
	{
	  key = data.slice(next, next + 4)
	  next += 4;
	}
	
	if(Opcode ==1 || Opcode ==2 )
	{
	var loops =1;
    if(length > 65535)
	  loops = Math.ceil(length/65535);
	 var message = data.slice(next);
	
	
	for (var i = 0; i <  message.length; i++) {
		
       decoded[i] =  (message[i] ^ key[i % 4]);
      }
	  
			if(Opcode === 1 || Opcode ===2)
			{
				if(decoded.length !==0)
			     this.continiousData.push(decoded);
				
			}
            
			    var b;
			   if(FIN!==0)
			     {
			      b =buff.concat(this.continiousData);
				  this.continiousData =[];
				 }
			 
			  if(FIN!==0 && Opcode ===1)
			  {
				  
				   var obj  = JSON.parse(b.toString('ascii'));
				   //console.log(obj);
				   if(obj.message_type == "HANDSHAKE")
				   {
					  
					  // this.user = obj.user !== undefined ? obj.user:'guest'+sockets.length;
					   this.appID = obj.appID;
					   if(obj.user !==undefined)
					    {
						  sockets[obj.user] =  this;
						  this.socket.user = obj.user;
						  this.user = obj.user;
						}
					  else
					   {
					    sockets['guest'+sockets.length] = this;
						 this.user = 'guest'+sockets.length;
						 this.socket.user = this.user;
					   }
						
					
						
					// console.log(sockets);
				   }
				    if(obj.message_type == "DISCONECT")
				   {
					   this.socket.end();
				   }
				// vat temp = this.params;
				  this.params.unshift(b.toString('ascii'));
				  
			      this.controler[this.receiver].apply(this.controler,this.params);
				  this.params.splice(0,1);
				  console.log(this.params);
			  }
			   else if (FIN !==0 && Opcode ===2)
			   {
				
				this.params.unshift(b.toString('binary'));
			    this.controler[this.receiver].apply(this.controler,this.params);
			   }
	}
  this.sendData('joke thet man');
}

websocket.prototype.sendData = function(message, socket)
{
	var reservedBytes = [];
	reservedBytes[0]=129;
	var length = message.length;
	var startdata = 2;
	if(length <= 125)
	{
		reservedBytes[1]=length;
	}
	else if(length >126 && length < 65535)
	{
		reservedBytes[1]=126;
		reservedBytes[2] = (length & 0xFF) >> 8;
		reservedBytes[3] = (length & 0xFF);
		
		startdata = 4;
		
	}
	else
	{
		reservedBytes[1]=127;
		reservedBytes[2] = (length & 0xFF) >> 56;
		reservedBytes[3] = (length & 0xFF) >> 48;
		reservedBytes[4] = (length & 0xFF) >> 40;
		reservedBytes[4] = (length & 0xFF) >> 32;
		reservedBytes[6] = (length & 0xFF) >> 24;
		reservedBytes[7] = (length & 0xFF) >> 16;
		reservedBytes[8] = (length & 0xFF) >> 8;
		reservedBytes[9] = (length & 0xFF);
		startdata = 10;
		
		
	}
	 for (var i = 0; i < message.length; i++){
        reservedBytes.push(message.charCodeAt(i));
    }
	
	var bf = new buff(reservedBytes.toString());
	//console.log(reservedBytes);
	//this.controler[this.sender]()
	this.socket.write(new buff(reservedBytes));
	
}

websocket.prototype.onclose = function()
{
	console.log(this.user);
	delete sockets[this.user];
	console.log('closed');
	console.log(sockets);
}


module.exports = websocket;